{"title":"The SQL Is Never As Good As The Original","markdown":{"yaml":{"title":"The SQL Is Never As Good As The Original","description":"SQL is a popular way of working with data. Advanced users probably do a lot with it alone, but even just having a working knowledge of SQL has increased the number of datasets that I can get data from to then analyse with other tools such as R or Python. You can use SQL within RStudio if you want. The following are a few notes to help future-Rohan when he needs to use SQL. A worked example with a sample of the Hansard data will be included in a future post.\n","author":[{"name":"Rohan Alexander"}],"date":"2018-07-28","output":{"distill::distill_article":{"self_contained":false}}},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(tidyverse)\n```\n\n\n*Thanks to Monica for the title.*\n\nSQL is a popular way of working with data. Advanced users probably do a lot with it alone, but even just having a working knowledge of SQL has increased the number of datasets that I can get data from to then analyse with other tools such as R or Python. You can use SQL within RStudio if you want. The following are a few notes to help future-Rohan when he needs to use SQL. A worked example with a sample of the Hansard data will be included in a future post.\n\n![](https://imgs.xkcd.com/comics/query.png)\n\nSQL is fairly straightforward if you've used mutate, filter and join in the R tidyverse as the concepts (and sometimes even the verb) are the same. In that case, half the battle is getting used to the terminology, and the other half is getting on top of the order of operations because SQL can be a tad pedantic.\n\nSQL (\"see-quell\" or \"S.Q.L.\" - both camps seem fairly insistent on their way...) is used with relational databases. A relational database is just a collection of at least one table, and a table is just some data organized into rows and columns. If there's more than one table in the database, then there should be some column that links them. Using it feels a bit like HTML/CSS in terms of being halfway between markup and programming. One fun aspect is that line spaces mean nothing: include them or don't, but always end a SQL command in a semicolon;\n\n# Creating a table\nCreate an empty table of three columns of type: int, text, int:\n\n```{sql, include = TRUE, eval = FALSE}\nCREATE TABLE table_name (\n  column1 INTEGER,\n  column2 TEXT,\n  column3 INTEGER\n);\n```\n\nAdd a row of data:\n\n```{sql, include = TRUE, eval = FALSE}\nINSERT INTO table_name (column1, column2, column3)\n  VALUES (1234, 'Gough Menzies', 32);\n```\n\nAdd a column:\n\n```{sql, include = TRUE, eval = FALSE}\nALTER TABLE table_name\n  ADD COLUMN column4 TEXT;\n```\n\n# Viewing the data\nSee one column (similar to R's select):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column2\n  FROM table_name;\n```\nSee two columns:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column1, column2\n  FROM table_name;\n```\n\nSee all columns:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name;\n```\n\nSee unique rows in a column (similar to R's distinct):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT DISTINCT column2\n  FROM table_name;\n```\n\nSee the rows that match a criteria (similar idea to R's which or filter):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column3 > 30;\n```\n\nAll the usual operators are fine with WHERE: =, !=, >, <, >=, <=. Just make sure the condition evaluates to true/false.\n\nSee the rows that are pretty close to a criteria:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 LIKE  '_ough Menzies';\n```\n\nThe _ above is a wildcard that matches to any character e.g. 'Cough Menzies' would be matched here, as would 'Gough Menzies'. LIKE is not case-sensitive: 'Gough Menzies' and 'gough menzies' would both match here.\n\nUse % as an anchor to matches pieces:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 LIKE  '%Menzies';\n```\n\nThat matches anything ending with 'Menzies', so 'Cough Menzies', 'Gough Menzies', 'Sir Menzies' etc, would all be matched here. Use surrounding percentages to match within, e.g. %Menzies% would also match 'Sir Menzies Jr' whereas %Menzies would not.\n\nThis is wild: NULL values (!) (True/False/NULL) are possible, not just True/False, but they need to be explicitly matched for:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 IS NOT NULL;\n```\n\nThis too is wild: There's an underlying ordering build into number, date and text fields that allows you to use BETWEEN on all those, not just numeric! The following looks for text that starts with a letter between A and M (not including M) so would match 'Gough Menzies', but not 'Sir Gough Menzies'!\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 BETWEEN 'A' AND 'M';\n```\n\nIf you look for a numeric (as opposed to text) then BETWEEN is inclusive.\n\nCombine conditions with AND (both must be true to be returned) or OR (at least one must be true):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 BETWEEN 'A' AND 'M'\n    AND column3 = 32;\n```\n\nYou can order the result:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    ORDER BY column3;\n```\n\nAscending is the default, add DESC for alternative:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    ORDER BY column3 DESC;\n```\n\nRestrict the return to a certain number of values by adding LIMIT at the end:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    ORDER BY column3 DESC\n    LIMIT 1;\n```\n(This doesn't work all the time - only certain SQL databases.)\n\n# Modifying data and using logic\nEdit a value:\n\n```{sql, include = TRUE, eval = FALSE}\nUPDATE table_name\n  SET column3 = 33\n    WHERE column1 = 1234;\n```\n\nImplement if/else logic:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *,\n  CASE\n    WHEN column2 = 'Gough Whitlam' THEN 'Labor'\n    WHEN column2 = 'Robert Menzies' THEN 'Liberal'\n    ELSE 'Who knows'\n  END AS 'Party'\n  FROM table_name;\n```\nThis returns a column called 'Party' that looks at the name of the person to return a party.\n\nDelete some rows:\n\n```{sql, include = TRUE, eval = FALSE}\nDELETE FROM table_name\n  WHERE column3 IS NULL;\n```\n\nAdd an alias to a column name (this just shows in the output):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column2 AS 'Names'\n  FROM table_name;\n```\n\n# Summarising data\nWe can use COUNT, SUM, MAX, MIN, AVG and ROUND in the place of summarise in R. COUNT counts the number of rows that are not empty for some column by passing the column name, or for all using *:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT COUNT(*)\n  FROM table_name;\n```\n\nSimilarly, pass a column to SUM, MAX, MIN, and AVG:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT SUM(column1)\n  FROM table_name;\n```\n\nROUND takes a column and an integer to specify how many decimal places:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT ROUND(column1, 0)\n  FROM table_name;\n```\n\nSELECT and GROUP BY is similar to group_by in R:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column3, COUNT(*)\n  FROM table_name\n    GROUP BY column3;\n```\n\nYou can GROUP BY column number instead of name e.g. 1 instead of column3 in the GROUP BY line or 2 instead of COUNT(*) if that was of interest.\n\nHAVING for aggregates, is similar to filter in R or the WHERE for rows from earlier. Use it after GROUP BY and before ORDER BY and LIMIT.\n\n# Combining data\nCombine two tables using JOIN or LEFT JOIN:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table1_name\n  JOIN table2_name\n    ON table1_name.colum1 = table2_name.column1;\n```\n\nBe careful to specify the matching columns using dot notation. Primary key columns uniquely identify rows and are: 1) never NULL; 2) unique; 3) only one column per table. A primary key can be primary in one table and foreign in another. Unique columns have a different value for every row and there can be many in one table.\n\nUNION is the equivalent of cbind if the tables are already fairly similar.\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(tidyverse)\n```\n\n\n*Thanks to Monica for the title.*\n\n# Introduction\nSQL is a popular way of working with data. Advanced users probably do a lot with it alone, but even just having a working knowledge of SQL has increased the number of datasets that I can get data from to then analyse with other tools such as R or Python. You can use SQL within RStudio if you want. The following are a few notes to help future-Rohan when he needs to use SQL. A worked example with a sample of the Hansard data will be included in a future post.\n\n![](https://imgs.xkcd.com/comics/query.png)\n\nSQL is fairly straightforward if you've used mutate, filter and join in the R tidyverse as the concepts (and sometimes even the verb) are the same. In that case, half the battle is getting used to the terminology, and the other half is getting on top of the order of operations because SQL can be a tad pedantic.\n\nSQL (\"see-quell\" or \"S.Q.L.\" - both camps seem fairly insistent on their way...) is used with relational databases. A relational database is just a collection of at least one table, and a table is just some data organized into rows and columns. If there's more than one table in the database, then there should be some column that links them. Using it feels a bit like HTML/CSS in terms of being halfway between markup and programming. One fun aspect is that line spaces mean nothing: include them or don't, but always end a SQL command in a semicolon;\n\n# Creating a table\nCreate an empty table of three columns of type: int, text, int:\n\n```{sql, include = TRUE, eval = FALSE}\nCREATE TABLE table_name (\n  column1 INTEGER,\n  column2 TEXT,\n  column3 INTEGER\n);\n```\n\nAdd a row of data:\n\n```{sql, include = TRUE, eval = FALSE}\nINSERT INTO table_name (column1, column2, column3)\n  VALUES (1234, 'Gough Menzies', 32);\n```\n\nAdd a column:\n\n```{sql, include = TRUE, eval = FALSE}\nALTER TABLE table_name\n  ADD COLUMN column4 TEXT;\n```\n\n# Viewing the data\nSee one column (similar to R's select):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column2\n  FROM table_name;\n```\nSee two columns:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column1, column2\n  FROM table_name;\n```\n\nSee all columns:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name;\n```\n\nSee unique rows in a column (similar to R's distinct):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT DISTINCT column2\n  FROM table_name;\n```\n\nSee the rows that match a criteria (similar idea to R's which or filter):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column3 > 30;\n```\n\nAll the usual operators are fine with WHERE: =, !=, >, <, >=, <=. Just make sure the condition evaluates to true/false.\n\nSee the rows that are pretty close to a criteria:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 LIKE  '_ough Menzies';\n```\n\nThe _ above is a wildcard that matches to any character e.g. 'Cough Menzies' would be matched here, as would 'Gough Menzies'. LIKE is not case-sensitive: 'Gough Menzies' and 'gough menzies' would both match here.\n\nUse % as an anchor to matches pieces:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 LIKE  '%Menzies';\n```\n\nThat matches anything ending with 'Menzies', so 'Cough Menzies', 'Gough Menzies', 'Sir Menzies' etc, would all be matched here. Use surrounding percentages to match within, e.g. %Menzies% would also match 'Sir Menzies Jr' whereas %Menzies would not.\n\nThis is wild: NULL values (!) (True/False/NULL) are possible, not just True/False, but they need to be explicitly matched for:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 IS NOT NULL;\n```\n\nThis too is wild: There's an underlying ordering build into number, date and text fields that allows you to use BETWEEN on all those, not just numeric! The following looks for text that starts with a letter between A and M (not including M) so would match 'Gough Menzies', but not 'Sir Gough Menzies'!\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 BETWEEN 'A' AND 'M';\n```\n\nIf you look for a numeric (as opposed to text) then BETWEEN is inclusive.\n\nCombine conditions with AND (both must be true to be returned) or OR (at least one must be true):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    WHERE column2 BETWEEN 'A' AND 'M'\n    AND column3 = 32;\n```\n\nYou can order the result:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    ORDER BY column3;\n```\n\nAscending is the default, add DESC for alternative:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    ORDER BY column3 DESC;\n```\n\nRestrict the return to a certain number of values by adding LIMIT at the end:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table_name\n    ORDER BY column3 DESC\n    LIMIT 1;\n```\n(This doesn't work all the time - only certain SQL databases.)\n\n# Modifying data and using logic\nEdit a value:\n\n```{sql, include = TRUE, eval = FALSE}\nUPDATE table_name\n  SET column3 = 33\n    WHERE column1 = 1234;\n```\n\nImplement if/else logic:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *,\n  CASE\n    WHEN column2 = 'Gough Whitlam' THEN 'Labor'\n    WHEN column2 = 'Robert Menzies' THEN 'Liberal'\n    ELSE 'Who knows'\n  END AS 'Party'\n  FROM table_name;\n```\nThis returns a column called 'Party' that looks at the name of the person to return a party.\n\nDelete some rows:\n\n```{sql, include = TRUE, eval = FALSE}\nDELETE FROM table_name\n  WHERE column3 IS NULL;\n```\n\nAdd an alias to a column name (this just shows in the output):\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column2 AS 'Names'\n  FROM table_name;\n```\n\n# Summarising data\nWe can use COUNT, SUM, MAX, MIN, AVG and ROUND in the place of summarise in R. COUNT counts the number of rows that are not empty for some column by passing the column name, or for all using *:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT COUNT(*)\n  FROM table_name;\n```\n\nSimilarly, pass a column to SUM, MAX, MIN, and AVG:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT SUM(column1)\n  FROM table_name;\n```\n\nROUND takes a column and an integer to specify how many decimal places:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT ROUND(column1, 0)\n  FROM table_name;\n```\n\nSELECT and GROUP BY is similar to group_by in R:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT column3, COUNT(*)\n  FROM table_name\n    GROUP BY column3;\n```\n\nYou can GROUP BY column number instead of name e.g. 1 instead of column3 in the GROUP BY line or 2 instead of COUNT(*) if that was of interest.\n\nHAVING for aggregates, is similar to filter in R or the WHERE for rows from earlier. Use it after GROUP BY and before ORDER BY and LIMIT.\n\n# Combining data\nCombine two tables using JOIN or LEFT JOIN:\n\n```{sql, include = TRUE, eval = FALSE}\nSELECT *\n  FROM table1_name\n  JOIN table2_name\n    ON table1_name.colum1 = table2_name.column1;\n```\n\nBe careful to specify the matching columns using dot notation. Primary key columns uniquely identify rows and are: 1) never NULL; 2) unique; 3) only one column per table. A primary key can be primary in one table and foreign in another. Unique columns have a different value for every row and there can be many in one table.\n\nUNION is the equivalent of cbind if the tables are already fairly similar.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":{"distill::distill_article":{"self_contained":false}},"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../styles.css"],"toc":true,"output-file":"the-sql-is-never-as-good-as-the-original.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Danger","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.266","theme":"cosmo","title":"The SQL Is Never As Good As The Original","description":"SQL is a popular way of working with data. Advanced users probably do a lot with it alone, but even just having a working knowledge of SQL has increased the number of datasets that I can get data from to then analyse with other tools such as R or Python. You can use SQL within RStudio if you want. The following are a few notes to help future-Rohan when he needs to use SQL. A worked example with a sample of the Hansard data will be included in a future post.\n","author":[{"name":"Rohan Alexander"}],"date":"2018-07-28"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
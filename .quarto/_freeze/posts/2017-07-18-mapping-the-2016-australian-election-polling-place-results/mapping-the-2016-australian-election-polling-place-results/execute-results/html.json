{
  "hash": "a1768b681c9bba7dc05a94621babc99e",
  "result": {
    "markdown": "---\ntitle: \"Mapping the 2016 Australian Election Polling Place Results\"\ndescription: |\n  The note that follows introduces Australia's political system, and then details the process of downloading and merging first-preference votes by polling place, and then plotting it on an interactive map.\nauthor:\n  - name: Rohan Alexander\ndate: 2017-07-18\noutput:\n  distill::distill_article:\n    self_contained: false\n---\n\n\n\n::: {.cell}\n<iframe src=\"https://rohanalexander.shinyapps.io/polling_place_firstpref_winner/?showcase=0\" width=\"672\" height=\"600px\" data-external=\"1\"></iframe>\n:::\n\n\nThe note that follows introduces Australia's political system, and then details the process of downloading and merging first-preference votes by polling place, and then plotting it on an interactive map.\n\n# Australia's political system\nIn 2016 Australia's federal government was determined by the outcomes of elections in 150 divisions which each elected one member to the lower house. The Liberal/National Coalition won 76 seats which allowed it to form a majority government; while the Labor party won 69 seats to form the Opposition; the Greens and the Nick Xenophon Team each won one seat; and there were two Independent members (Andrew Wilkie and Cathy McGowan).\n\nVotes are cast at polling places in each division. In general voters can go to any polling place within their registered division, but some polling places that are close to a boundary will allow voting from there and some major polling places (such as the city hall of a state capital) will allow voting in any division. \n\nAlthough there are some exceptions divisions are generally constructed so that they each have roughly the same number of people. However this is not the case for polling places -- some are much larger than others. Nonetheless it is interesting to see the geographic distribution of which party received the most first-preference votes in each polling place, especially in the context of which party won the division.\n\n\n# Polling place data\nThe main packages for the data manipulation are the tidyverse and magrittr. leaflet allows the creation of interactive maps, ggmap creates static maps, and rgdal assists with dealing with geographic data. rmapshaper is used to reduce the size of the shapefile of division boundaries so that it is faster to load.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(leaflet)\nlibrary(ggmap)\nlibrary(rgdal)\nlibrary(rmapshaper)\n```\n:::\n\n\nThe polling place results can be downloaded by state from the AEC website at http://results.aec.gov.au/20499/Website/HouseDownloadsMenu-20499-Csv.htm. There the AEC also makes available a dataset that contains geocodes for each of the polling places. The separate datasets for each state need to be merged, and then each polling place needs to be geocoded. Finally some minor changes are needed to make the party names easier to follow.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Read in the polling place datasets (are state specific), and the geocodes for each polling place. Then put it all together to have one geocoded polling place dataset for all of Australia: Australia_booths. Finally, create a dataset that is filtered so that it just shows the winner of each booth: Australia_booths_winner. ####\n# Data importing\ngeocodes <- read_csv(\"data/GeneralPollingPlacesDownload-20499.csv\", skip = 1)\nNSW_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-NSW.csv\", skip = 1)\nQLD_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-QLD.csv\", skip = 1)\nVIC_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-VIC.csv\", skip = 1)\nACT_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-ACT.csv\", skip = 1)\nTAS_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-TAS.csv\", skip = 1)\nSA_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-SA.csv\", skip = 1)\nWA_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-WA.csv\", skip = 1)\nNT_booths <- read_csv(\"data/HouseStateFirstPrefsByPollingPlaceDownload-20499-NT.csv\", skip = 1)\n# Merge\nAustralia_booths <- rbind(NSW_booths, QLD_booths, VIC_booths, ACT_booths, TAS_booths, SA_booths, WA_booths, NT_booths)\n# Add the geocodes\nAustralia_booths <- Australia_booths %>% \n  left_join(geocodes)\n# Clean up\nrm(NSW_booths, QLD_booths, VIC_booths, ACT_booths, TAS_booths, SA_booths, WA_booths, NT_booths)\n# If you need it use this to get a list of the parties, ordered by the number of first-preference votes\n# first_votes <- Australia_booths %>%\n#   group_by(PartyNm) %>%\n#   summarise(votes = sum(OrdinaryVotes, na.rm = TRUE)) %>%\n#   arrange(desc(votes))\n# Combine some parties that are separate, but equivalent: Australian Labor Party & Australian Labor Party (Northern Territory) Branch & Labor, Country Liberals (NT) & Liberal, The Greens & The Greens (WA).\nAustralia_booths$PartyNm <- recode(Australia_booths$PartyNm, \"Australian Labor Party (Northern Territory) Branch\" = \"Australian Labor Party\", \"Labor\" = \"Australian Labor Party\")\nAustralia_booths$PartyNm <- recode(Australia_booths$PartyNm, \"Country Liberals (NT)\" = \"Liberal/LNP\", \"Liberal National Party of Queensland\" = \"Liberal/LNP\", \"Liberal\" = \"Liberal/LNP\")\nAustralia_booths$PartyNm <- recode(Australia_booths$PartyNm, \"The Greens (WA)\" = \"The Greens\")\n# Create an indicator for who won the polling place then filter on that\nAustralia_booths_winner <- Australia_booths %>% \n  group_by(PollingPlaceID) %>% \n  mutate(polling_place_winner = ifelse(max(OrdinaryVotes) == OrdinaryVotes, max(OrdinaryVotes), 0)) %>%\n  filter(polling_place_winner >= 1)\n#table(Australia_booths_winner$PartyNm)\n# There are three parties that only win one booth, so combine all those into 'Other'\nAustralia_booths_winner$PartyNm <- recode(Australia_booths_winner$PartyNm, \"Australian Recreational Fishers Party\" = \"Other\", \"Christian Democratic Party (Fred Nile Group)\" = \"Other\", \"Derryn Hinch's Justice Party\" = \"Other\")\n```\n:::\n\n\n# Division data\nThe divisions can be coloured based on which party won overall. The map of the boundaries for each division can be downloaded from the AEC website here: http://www.aec.gov.au/Electorates/gis/gis_datadownload.htm. The shapefile doesn't have winner of each division so this needs to be merged into it. It is important to put the shapefile dataset first when merging. Finally, the shapefile is quite a large file and this can be reduced for faster loading.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Read in the shapefiles (maps) that show each of the boundaries of the divisions (electorates) then add the data to say who won that division. Result is a spatial dataframe called boundaries. ####\n# Overall winner for each division, which will be used to color the division\nDivision_winner <- read_csv(\"data/HouseMembersElectedDownload-20499.csv\", skip = 1)\n# The boundaries of the divisions (downloaded from: http://www.aec.gov.au/Electorates/gis/gis_datadownload.htm)\nboundaries <- readOGR(dsn = \"data/national-midmif-09052016/COM_ELB.TAB\", layer = \"COM_ELB\")\n# Fix a couple - Mcmillan and Mcpherson - that have capitalisation issues\nboundaries$Elect_div <- recode(boundaries$Elect_div, \"Mcmillan\" = \"McMillan\", \"Mcpherson\" = \"McPherson\")\n# Add the overall division winner dataset into the boundaries dataset (thanks to http://www.nickeubank.com/wp-content/uploads/2015/10/RGIS2_MergingSpatialData_part1_Joins.html)\nboundaries <- merge(boundaries, Division_winner, by.x = \"Elect_div\", by.y = \"DivisionNm\")\n# Simplify and reduce the size of the shapefile so that it loads better\nobject.size(boundaries)\nboundaries <- rmapshaper::ms_simplify(boundaries)\nobject.size(boundaries)\n# Clean up\nrm(Division_winner)\n```\n:::\n\n\nThen colours need to be associated with each party.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Specify the colour schemes that will be used. ####\n# Set the color scheme for the booth coloring\n# pal <- colorFactor(\n#   palette = \"Dark2\", \n#   domain = unique(Australia_booths$PartyNm)\npal <- colorFactor(palette = c(\"#c04745\", \"#616161\", \"black\", \"purple4\", \"#4776be\", \"#ff5800\", \"cyan1\", \"yellow\", \"#a8c832\", \"brown4\"), \n                          domain = c(\"Australian Labor Party\", \"Independent\", \"Informal\", \"Katter's Australian Party\", \"Liberal/LNP\", \"Nick Xenophon Team\", \"Other\", \"Pauline Hanson's One Nation\", \"The Greens\", \"The Nationals\"))\n# Set the color scheme for the division coloring\npall <- colorFactor(palette = c(\"#c04745\", \"#616161\", \"purple4\", \"#4776be\", \"#4776be\", \"#ff5800\", \"#a8c832\", \"brown4\"), \n                   domain = c(\"Australian Labor Party\", \"Independent\", \"Katter's Australian Party\", \"Liberal\", \"Liberal National Party\", \"Nick Xenophon Team\", \"The Greens\", \"The Nationals\"))\n```\n:::\n\n\n# Interactive map\nFinally, the map can be produced:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Pull it all together to make the map ####\n# Make the map\nAustralia_map <- \n  leaflet() %>%\n  # Base groups\n  addTiles() %>%  # Add default OpenStreetMap map tiles\n  addProviderTiles(providers$Stamen.TonerLite, group = \"Toner Lite\") %>% # Add a black and white alternative\n  setView(lng = 133.7751, lat = -25.2744, zoom = 4) %>% # Specify where the map is initially focused\n  addPolygons(data = boundaries, \n              color = \"#444444\", \n              weight = 1, \n              smoothFactor = 0.5,\n              opacity = 1.0, \n              fillColor = pall(boundaries$PartyNm),\n              highlightOptions = highlightOptions(color = \"#666\", weight = 2, bringToFront = FALSE)) %>% # Add the plot of the divisions, coloured by which party won it\n  addCircles(\n    data = Australia_booths_winner,\n    lng = Australia_booths_winner$Longitude, \n    lat = Australia_booths_winner$Latitude, \n    popup = paste(\"<b>Division:</b>\", as.character(Australia_booths_winner$DivisionNm), \"<br>\",\n                  \"<b>Polling place:</b>\", as.character(Australia_booths_winner$PollingPlaceNm), \"<br>\",\n                  \"<b>Address:</b>\", as.character(Australia_booths_winner$PremisesAddress1), \"<br>\",\n                  \"<b>Party with most first-pref votes:</b>\", as.character(Australia_booths_winner$PartyNm), \"<br>\",\n                  \"<b>First-pref votes:</b>\", as.character(Australia_booths_winner$OrdinaryVotes), \"<br>\"),\n    label = ~as.character(Australia_booths_winner$DivisionNm),\n    #clusterOptions = markerClusterOptions(),\n    color = pal(Australia_booths_winner$PartyNm),\n    fillOpacity = 0.5) %>% # Plot the booths, coloured by which party got the most first-preferences.\n  # Layers control\n  addLayersControl(\n    baseGroups = c(\"OSM (default)\", \"Toner Lite\"),\n    options = layersControlOptions(collapsed = FALSE)\n  ) %>%\n  addLegend(\"bottomright\", pal = pal, values = Australia_booths_winner$PartyNm,\n            title = \"Which party won\",\n            #labFormat = labelFormat(prefix = \"$\"),\n            opacity = 1\n  )\n# Call the map\nAustralia_map\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
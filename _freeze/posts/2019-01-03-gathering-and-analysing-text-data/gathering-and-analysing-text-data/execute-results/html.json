{
  "hash": "692db152ae9b00deeaf45dea5afbc868",
  "result": {
    "markdown": "---\ntitle: \"Gathering and analysing text data\"\ndescription: |\n  Text modelling is an exciting area of research. But many guides assume that you already have a nice dataset. Similarly, web scraping is an exciting way to get information, but not many explanations go on to explain what you could do with it. This post attempts to go from scraping text from a website through to modelling the topics. It's not meant to be an exhaustive post, but should hopefully provide enough that you can get started with your own project and know where to go for more information.\nauthor:\n  - name: Rohan Alexander\ndate: 01-03-2019\noutput:\n  distill::distill_article:\n    toc: true\n    self_contained: false\n---\n\n\n\n\n# Introduction\n\nText modelling is an exciting area of research. But many guides assume that you already have a nice dataset. Similarly, web scraping is an exciting way to get information, but not many explanations go on to explain what you could do with it. This post attempts to go from scraping text from a website through to modelling the topics. It's not meant to be an exhaustive post, but should hopefully provide enough that you can get started with your own project and know where to go for more information.\n\nThe example that I'm going to use is getting data from the minutes of the RBA board meeting.\n\n# Gathering data\n\nThe first step is to get some data. I'm going to use the rvest package to do the web scraping. When you are scraping data you should try to be polite - slow down your requests as much as possible, avoid times you know they'll have a lot of traffic, and check if the website has an API or a robots.txt file (usually access that at domain.com/robots.txt) that provides guidance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# install.packages(\"rvest\")\nlibrary(rvest)\n# install.packages(\"tidyverse\")\nlibrary(tidyverse)\n\n# Read in the list of the website addresses\ndata_to_scrape <- read_csv(\"inputs/addresses.csv\") # Just a list of the URLs \n# and dates for each minutes.\naddress_to_visit <- data_to_scrape$address\nsave_name <- data_to_scrape$save_name\n\n# Create the function that will visit address_to_visit and save to save_name files\nvisit_address_and_save_content <-\n  function(name_of_address_to_visit,\n           name_of_file_to_save_as) {\n    # The function takes two inputs\n    read_html(name_of_address_to_visit) %>% # Go to the website and read the html\n      html_node(\"#content\") %>% # Find the content part\n      html_text() %>% # Extract the text of the content part\n      write_lines(name_of_file_to_save_as) # Save as a text file\n    print(paste(\"Done with\", name_of_address_to_visit, \"at\", Sys.time()))  \n    # Helpful so that you know progress when running it on all the records\n    Sys.sleep(sample(30:60, 1)) # Space out each request by somewhere between \n    # 30 and 60 seconds each so that we don't overwhelm their server\n  }\n\n# If there is an error then ignore it and move to the next one\nvisit_address_and_save_content <-\n  safely(visit_address_and_save_content)\n\n# Walk through the addresses and apply the function to each\nwalk2(address_to_visit,\n      save_name,\n      ~ visit_address_and_save_content(.x, .y)) \n```\n:::\n\n\nThe CSV with the addresses and save names that we use looks something like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n|address                                                                       |save_name                     |\n|:-----------------------------------------------------------------------------|:-----------------------------|\n|https://www.rba.gov.au/monetary-policy/rba-board-minutes/2018/2018-11-06.html |inputs/minutes/2018-11-06.txt |\n|https://www.rba.gov.au/monetary-policy/rba-board-minutes/2018/2018-10-02.html |inputs/minutes/2018-10-02.txt |\n|https://www.rba.gov.au/monetary-policy/rba-board-minutes/2018/2018-09-04.html |inputs/minutes/2018-09-04.txt |\n|https://www.rba.gov.au/monetary-policy/rba-board-minutes/2018/2018-08-07.html |inputs/minutes/2018-08-07.txt |\n|https://www.rba.gov.au/monetary-policy/rba-board-minutes/2018/2018-07-03.html |inputs/minutes/2018-07-03.txt |\n:::\n:::\n\n\n\n\n# Analysing data\n\nIn this example we'll use a whole bunch of packages so that you can see what's available. In general probably stringr, quanteda and stm are the workhorse packages with others used as needed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Workspace set-up ####\n# install.packages(\"broom\")\nlibrary(broom) # Used to clean up results\n# install.packages(\"devtools\")\nlibrary(devtools)\n# devtools::install_github(\"DavisVaughan/furrr\")\nlibrary(furrr) # Used to do parallel processing with the topic models\nplan(multiprocess)\n# install.packages(\"quanteda\")\nlibrary(quanteda) # Used for data cleaning\n# install.packages(\"readtext\")\nlibrary(readtext) # Used to read in the txt files that were scraped\n# install.packages(\"stm\")\nlibrary(stm) # Used for more interesting topic models\n# install.packages(\"tictoc\")\nlibrary(tictoc) # Used for timing\n# install.packages(\"tidytext\")\nlibrary(tidytext)\n# install.packages(\"tidyverse\")\nlibrary(tidyverse) # Used for everything\n# install.packages('topicmodels')\nlibrary(topicmodels) # Used to make basic topic models\n\n# Read in the text that we scraped earlier\ntext <- readtext::readtext(\"inputs/minutes/*.txt\") # readtext makes this easy, \n# but could also use the usual base approach of listing files that end in txt etc.\n```\n:::\n\n\nIn general you'll often need to do a lot of cleaning before you can do the stats bit and get results. Here, I'll just show two example steps. I've found that cleaning the dataset seems to take about 80 per cent of the time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Clean data ####\n# Do some basic cleaning - remove puncuation and change everything to lower case\ntext$text <- str_to_lower(text$text)\ntext$text <- str_replace_all(text$text, \"[:punct:]\", \" \")\n```\n:::\n\n\nNow that we have a plausibly clean dataset (of course you'd want to come back and clean it more if you were actually interested in analysing the RBA minutes), we can try a topic model. Topic models are essentially just summaries. Instead of a document becoming a collection of words, they become a collection of topics with some probability associated with each topic. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### First topic modelling ####\n# Convert the corpus to a form that the topic model can work with\nrba_minutes <- quanteda::corpus(text) %>% # Minimum viable conversion\n  quanteda::dfm(remove_punct = TRUE, remove = stopwords('en')) %>% # Get rid of\n  # punctuation (in case you didn't already do that) and stop words - check \n  # those stop words assumptions\n  quanteda::dfm_trim(min_termfreq = 2, # Remove any word that doesn't occur at \n                     # least twice\n           min_docfreq = 2) # Get rid of any word that isn't in at least two documents\n\n# Run the topic model with 10 topics\ndtm <- quanteda::convert(rba_minutes, to = \"topicmodels\") # Getting the dfm \n# into a form that topicmodels can deal with\nlda_topics <- topicmodels::LDA(dtm, k = 10) # The k is the number of topics - \n# this decision has a big impact\n\n# Have a look at the terms\nterms(lda_topics, 10) # Top 10 words for each topic. Topics are just \n# probability distributions over words so you should look at different numbers of words\n```\n:::\n\n\n\nLooking at the words in the topics, it seems as though \"per\" and \"cent\" are being treated as separate words. The RBA is proud that it separates \"per\" and \"cent\", and if you're a grad there that'll stick with you for a while (see earlier paragraphs), but for our purposes they are one word and we need to combine them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Clean data ####\n# Let's deal with the first issue first.\ntext$text <- stringr::str_replace_all(text$text, \"perÂ cent\", \"per_cent\")\ntext$text <- stringr::str_replace_all(text$text, \"per cent\", \"per_cent\")\n\n# You could run the topic model again if you wanted.\n```\n:::\n\n\nRight, that issue of per cent has been fixed, but what if there are combinations of words like this that don't show up very high in the topics? To identify these we need to construct n-grams. Earlier with 'per' 'cent', we generated a 2-gram. Quanteda and the tidyverse makes it easy to identify popular n-grams (if your dataset is large then I'd work with a sample of it because these can get a little unwieldy, and we only really care about the popular ones anyway). Our text is in sentences, paragraphs, etc, and we first need to break it down into tokens (essentially separate words). There's a wonderful set of tutorials put together by the quanteda team here: https://tutorials.quanteda.io and the code for this section is from: https://tutorials.quanteda.io/basic-operations/tokens/tokens_ngrams/.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Adjusting for common co-location ####\ntoks <- tokens(text$text)\n# First generate 2-grams\nngrams <- tokens_ngrams(toks, n = 2:4)\n# Somewhat annoyingly for our purposes (although understandably given the broader \n# picture) quanteda puts tokens into its own class, so we need ot convert in \n# order to use the usual tidyverse tools that we may be more familiar with.\n# As a side note, I often find it worthwhile to checking class in R when there's \n# an issue because often that's part of the issue, in this case: class(ngrams).\n# The tokens class seems to just be a list, so we can unlist it and then put it \n# into a more-friendly tibble.\nngram_counts <- tibble(ngrams = unlist(ngrams)) %>% \n  count(ngrams, sort = TRUE)\n\n# We can identify a bunch of obvious replacements. If we start getting a long \n# list then we can create a file that holds the replacement.\ntext$text <- stringr::str_replace_all(text$text, \"assistant governor\", \"assistant_governor\")\ntext$text <- stringr::str_replace_all(text$text, \"reserve bank board\", \"reserve_bank_board\")\ntext$text <- stringr::str_replace_all(text$text, \"unemployment rate\", \"unemployment_rate\")\ntext$text <- stringr::str_replace_all(text$text, \"national accounts\", \"national_accounts\")\ntext$text <- stringr::str_replace_all(text$text, \"australian dollar\", \"australian_dollar\")\ntext$text <- stringr::str_replace_all(text$text, \"monetary policy\", \"monetary_policy\")\ntext$text <- stringr::str_replace_all(text$text, \"united states\", \"united_states\")\ntext$text <- stringr::str_replace_all(text$text, \"exchange rate\", \"exchange_rate\")\ntext$text <- stringr::str_replace_all(text$text, \"glenn stevens\", \"glenn_stevens\")\ntext$text <- stringr::str_replace_all(text$text, \"reserve bank\", \"reserve_bank\")\ntext$text <- stringr::str_replace_all(text$text, \"cash rate\", \"cash_rate\")\ntext$text <- stringr::str_replace_all(text$text, \"us dollar\", \"us_dollar\")\ntext$text <- stringr::str_replace_all(text$text, \"iron ore\", \"iron_ore\")\n\nrm(toks, ngrams, ngram_counts)\n```\n:::\n\n\nTake a look at the topics again. Notice that 'growth' is in essentially every topic. So is 'members' and a couple of others. It's not that growth isn't important (insert standard economist joke here), but the fact that 'members' shows up suggests that these may just be due to the way that language is used at the RBA, rather than communicating topics. If you read these minutes, you'll know that the RBA starts a LOT of sentences with 'Members noted...'. What does this mean for our purposes? Essentially, if you look at each topic by itself they seem 'coherent', but taken as a group it seems as though the topics are too similar. Another way to say that is that the words lack 'exclusivity'. This is a common tradeoff, and our results suggest that it may be worthwhile for us to reduce some of the coherence in order to increase the exclusivity. At this point, we'll use a different package for creating topic models - the STM package - because it has a bunch of nice features that you might like to take advantage of in future work.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Introducing STM and quanteda ####\nrba_minutes <- quanteda::corpus(text) %>% # Minimum viable conversion\n  quanteda::dfm(remove_punct = TRUE, \n                 remove_numbers = TRUE,\n                 remove = stopwords('en')) %>% # Get rid of punctuation (in \n  # case you didn't already do that) and stop words - check those stop words assumptions\n  quanteda::dfm_trim(min_termfreq = 2, # Remove any word that doesn't occur at least twice\n                     min_docfreq = 0.05, # Get rid of any word that isn't in at \n                     # least 5 per cent of documents\n                     max_docfreq = 0.90, # Get rid of any word that is in at \n                     # least 90 per cent of documents\n                     docfreq_type = \"prop\" # Above we specified percentages - you \n                     # could specify counts or ranks\n                     ) \n\n# We can run the topic model using STM\ntopics_stm <- stm(rba_minutes, K = 10)\n# Looking at the results you can see that the results are fairly similar to \n# those that we got from the topicmodels package, which is what we want. \nlabelTopics(topics_stm)\nrm(topics_stm)\n# If we were interested in the results then we might like to pre-process the text \n# a little more, for instance removing the names of months.\n```\n:::\n\n\nOther than pre-processing decisions, the other major determininat of the outputs of topic models is the number of topics specified. There are a bunch of diagnostic tests that have been developed to help with this decision and we can use some nice code from Julia Silge (https://juliasilge.com/blog/evaluating-stm/) to try a bunch of different values for the number of topics.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#### Deciding on the number of topics ####\ntic(\"With parallel\") # This allows us to time the code\nmany_models <- data_frame(K = seq(5, 20, by = 5)) %>% # Here we're running four \n  # topic models: 5 topics, 10 topics, 15 topics and 20 topics\n  mutate(topic_model = future_map(K, ~stm(rba_minutes, \n                                          K = .,\n                                          verbose = FALSE)))\ntoc()\n\n# You can also try setting K to zero within STM and seeing the number of topics \n# that it recommends: e,g, choose_topic_num_for_me <- stm(rba_minutes, K = 0, verbose = FALSE)\n\n# We want to compare those models with different numbers of topics using various diagnostics.\nheldout <- make.heldout(rba_minutes) # First create a test/training set\n\nk_result <- many_models %>%\n  mutate(exclusivity = map(topic_model, exclusivity), # How unique are words to the topics\n         semantic_coherence = map(topic_model, semanticCoherence, rba_minutes), # How \n         # much the topics tend to be coherent if we look at them (usually a \n         # tradeoff with exclusivity)\n         eval_heldout = map(topic_model, eval.heldout, heldout$missing),\n         residual = map(topic_model, checkResiduals, rba_minutes),\n         bound =  map_dbl(topic_model, function(x) max(x$convergence$bound)),\n         lfact = map_dbl(topic_model, function(x) lfactorial(x$settings$dim$K)),\n         lbound = bound + lfact,\n         iterations = map_dbl(topic_model, function(x) length(x$convergence$bound)))\n```\n:::\n\n\n\nPut these diagnostics into a nice summary graph (again code is Julia's originally).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk_result %>%\n  transmute(K,\n            `Lower bound` = lbound,\n            Residuals = map_dbl(residual, \"dispersion\"),\n            `Semantic coherence` = map_dbl(semantic_coherence, mean),\n            `Held-out likelihood` = map_dbl(eval_heldout, \"expected.heldout\")) %>%\n  gather(Metric, Value, -K) %>%\n  ggplot(aes(K, Value, color = Metric)) +\n  geom_line(show.legend = FALSE) +\n  facet_wrap(~Metric, scales = \"free_y\") +\n  labs(x = \"K (number of topics)\",\n       y = NULL,\n       title = \"Model diagnostics by number of topics\") +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](gathering-and-analysing-text-data_files/figure-html/diagnosticmeasuregraphs-1.png){width=672}\n:::\n:::\n\n\n\nIn general we are looking for the max/min of parabolas, so our results suggest we may be best with some more topics (go to Julia's post for to see another example: https://juliasilge.com/blog/evaluating-stm/.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Have a look at that exclusivity to coherence tradeoff\nk_result %>%\n  select(K, exclusivity, semantic_coherence) %>%\n  unnest() %>%\n  mutate(K = as.factor(K)) %>%\n  ggplot(aes(semantic_coherence, exclusivity)) +\n  geom_point() +\n  facet_wrap(vars(K)) +\n  labs(x = \"Semantic coherence\",\n       y = \"Exclusivity\",\n       title = \"Comparing exclusivity and semantic coherence\") +\n  theme_minimal()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `cols` is now required when using `unnest()`.\nâ¹ Please use `cols = c(exclusivity, semantic_coherence)`.\n```\n:::\n\n::: {.cell-output-display}\n![](gathering-and-analysing-text-data_files/figure-html/exlusitivty-1.png){width=672}\n:::\n:::\n\n\nAlthough you'd probably want more, let's just choose 10 topics for now. What we're most interested in is getting the betas and gammas so that we can do our usual analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntopic_model <- k_result %>% \n  filter(K == 10) %>% \n  pull(topic_model) %>% \n  .[[1]]\n\n# Grab the betas - these are the probability of each term in each topic\ntd_beta <- broom::tidy(topic_model, \n                       matrix = \"beta\")\n\n# Grab the gammas - these are the probability of each word in each topic\ntd_gamma <- tidy(topic_model, \n                 matrix = \"gamma\",\n                 document_names = rownames(rba_minutes))\n```\n:::\n\n\nFrom here you could look at how the gammas and betas evolve or change using a statistical model. Or even sometimes just looking at them is interesting. Julia Silge has a bunch of code that makes very nice graphs and tables. One of the advantages of the STM package is that it makes it easier to include specific types of additional information. For instance, we know that over our time period there have been two governors: GRS and Phil Lowe. We could associate each date with who the governor is and then allow that to affect the prevalence of certain topics.\n\nYou can grab the files and folder set up from GitHub if you'd like.",
    "supporting": [
      "gathering-and-analysing-text-data_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}